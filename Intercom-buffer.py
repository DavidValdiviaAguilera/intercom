from intercom_minimal import Intercom_minimal
import sounddevice as sd
import numpy as np
import psutil
import time
from multiprocessing import Process

# Accumulated percentage of used CPU. 
CPU_total = 0

# Number of samples of the CPU usage.
CPU_samples = 0

# CPU usage average.
CPU_average = 0

class Intercom_buffer(Intercom_minimal):

    CHUNK_NUMBERS = 2**15
    BUFFERING_TIME = 100

    def init(self, args):
        Intercom_minimal.init(self, args)
        #Los chunks del Buffer se tienen como la cantidad de chunks que se pueden rellenar
        #en el tiempo de buffer.
        self.chunks_to_buffer = int(args.buffering_time / self.chunk_time)
        print(args.buffering_time, self.chunk_time)
        print(f"Intercom_buffer: chunks_to_buffer={self.chunks_to_buffer}")
        
        #El Buffer tiene el doble de celdas que de chunks para mantener un
        #buffer ideal
        self.cells_in_buffer = self.chunks_to_buffer * 2
        print(f"Intercom_buffer: cells_in_buffer={self.cells_in_buffer}")
        # Initially, all the cells of the buffer will point to this
        # empty chunk.
        self.empty_chunk = self.generate_zero_chunk()

        # Running the user pacifier.
        p = Process(target=self.feedback)
        p.start()

    # Sends a chunk.
    def send_chunk(self, chunk):
        super().send(chunk)

    # Waits for a new chunk and insert it into the right position of
    # the buffer. As the receive_and_queue() method in
    # Intercom_minimal, this method is called from an infinite loop.
    def receive_and_buffer(self):
        message = self.receive()
        #Decodifica los primeros 2 bytes correspondientes a 
        #el numero de chunk
        (chunk_number,) = np.frombuffer(message[:2],dtype='>H')
        chunk = np.frombuffer(message[2:], np.int16).reshape(self.frames_per_chunk, self.number_of_channels)
        self._buffer[chunk_number % self.cells_in_buffer] = chunk
        return chunk_number
   
    # Gets the next available chunk from the buffer and send it to the
    # Digital Analog Converter (DAC) of the sound device. Then, the
    # played chunks are zeroed in the buffer.
    def play_chunk(self, DAC):
        chunk = self._buffer[self.played_chunk_number % self.cells_in_buffer]
        self._buffer[self.played_chunk_number % self.cells_in_buffer] = self.generate_zero_chunk()
        self.played_chunk_number = (self.played_chunk_number + 1) % self.cells_in_buffer
        DAC[:] = chunk
        
    def record_send_and_play(self, indata, outdata, frames, time, status):
        self.recorded_chunk_number = (self.recorded_chunk_number + 1) % self.CHUNK_NUMBERS
        #Metemos el mensaje y el numero de chunk en el mismo paquete
        #Codificamos los primeros 2 bytes correspondientes a 
        #el numero de chunk
        chunk = np.array(self.recorded_chunk_number,dtype='>H').tobytes() + indata.tobytes()
        #enviamos el paquete
        self.send_chunk(chunk)
        self.play_chunk(outdata)

    # Runs the intercom and implements the buffer's logic.
    def run(self):
        
        # Buffer creation.
        self._buffer = [None] * self.cells_in_buffer
        for i in range(self.cells_in_buffer):
            self._buffer[i] = self.empty_chunk

        # Chunks counters.
        self.recorded_chunk_number = 0
        self.played_chunk_number = 0

        print("Intercom_buffer: press <CTRL> + <c> to quit")
        print("Intercom_buffer: buffering ... ")

        with sd.Stream(samplerate=self.frames_per_second, blocksize=self.frames_per_chunk, dtype=self.sample_type, channels=self.number_of_channels, callback=self.record_send_and_play):
            first_received_chunk_number = self.receive_and_buffer()
            self.played_chunk_number = (first_received_chunk_number - self.chunks_to_buffer) % self.cells_in_buffer
            while True:
                self.receive_and_buffer()

    # Shows CPU usage.
    def print_feedback_message(self):
        # Be careful, variables updated only in the subprocess.
        global CPU_total
        global CPU_samples
        global CPU_average
        CPU_usage = psutil.cpu_percent()
        CPU_total += CPU_usage
        CPU_samples += 1
        CPU_average = CPU_total/CPU_samples
        print(f"{int(CPU_usage)}/{int(CPU_average)}", flush=True, end=' ')

    # This method runs in a different process to the intercom, and its
    # only task is to print the feedback messages with the CPU load,
    # waiting for the interrupt signal generated by the user (CTRL+C).
    def feedback(self):
        global CPU_average
        try:
            while True:
                self.print_feedback_message()
                time.sleep(1)
        except KeyboardInterrupt:
            print(f"\nIntercom_buffer: average CPU usage = {CPU_average} %")

    def add_args(self):
        parser = Intercom_minimal.add_args(self)
        parser.add_argument("-b", "--buffering_time",
                            help="Buffering time in ms.",
                            type=int, default=Intercom_buffer.BUFFERING_TIME)
        return parser

if __name__ == "__main__":
    intercom = Intercom_buffer()
    parser = intercom.add_args()
    args = parser.parse_args()
    intercom.init(args)
    try:
        intercom.run()
    except KeyboardInterrupt:
        print("Intercom_buffer: goodbye 2020¯\_(ツ)_/¯")
